#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

#define TRUE 1
#define FALSE 0
#define BYTECODE_SIZE 65536
#define STACK_SIZE 200

#define next_instruction \
	goto *(void *) (label_tab[*pc])

#define get_addr(pc) \
	(*(pc+1) & 0xFF) | (*(pc+2) << 8)

typedef uint8_t byte;
typedef uint16_t addr;
typedef int32_t stack_tt;

byte * read_bytecode(FILE * fp){
	int cur_byte, cnt;
	byte * bytecode;

	cnt = 0;
	bytecode = (byte *) malloc(BYTECODE_SIZE * sizeof(byte));

	if (bytecode == NULL)
		exit(EXIT_FAILURE);

	while ((cur_byte = getc(fp)) != EOF)
		bytecode[cnt++] = (char) cur_byte;

	return bytecode;
}

int main(int argc, char const *argv[])
{
	static void * label_tab[] = {
		&&halt,
		&&jump,
		&&jnz,
		&&dup,
		&&swap,
		&&drop,
		&&push4,
		&&push2,
		&&push1,
		&&add,
		&&sub,
		&&mul,
		&&div,
		&&mod,
		&&eq,
		&&ne,
		&&lt,
		&&gt,
		&&le,
		&&ge,
		&&not,
		&&and,
		&&or,
		&&input,
		&&output,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&nop,
		&&clock
	};

	if (argc < 2)
		exit(EXIT_FAILURE);

	// open byte_program file
	FILE * fp;
	fp = fopen(argv[1], "r");

	if (fp == NULL)
		exit(EXIT_FAILURE);

	// read byte_program
	byte * byte_program;
	byte_program = read_bytecode(fp);

	// init stack
	stack_tt * stack;
	stack = (stack_tt *) malloc(STACK_SIZE * sizeof(stack_tt));

// --------------------------------
	byte * pc;
	addr jmp_addr;

	stack_tt * sp;
	stack_tt arg, sarg, temp;
	stack_tt a,b;

	clock_t t; 
	double time_taken;
// --------------------------------

	// pc = &byte_program[0];
	pc = byte_program;
	// sp = &stack[0];
	sp = stack;

	t = clock(); 

	next_instruction;

halt:
	goto end;

jump:
	jmp_addr = get_addr(pc);

	pc = byte_program + jmp_addr;
	next_instruction;

jnz:
	arg = *(sp--);

	jmp_addr = get_addr(pc);
	pc = arg ? byte_program + jmp_addr : pc + 3;

	next_instruction;

dup:
	arg = *(++pc);
	sarg = *(sp - arg);
	*(++sp) = sarg;

	pc++;
	next_instruction;

swap:
	arg = *(++pc);
	sarg = *(sp - arg);

	temp = *sp;
	*sp = sarg;
	*(sp - arg) = temp;

	pc++;
	next_instruction;

drop:
	sp--;

	pc++;
	next_instruction;

push4:
	*(++sp) = *(int32_t *) (++pc);

	pc += 4;
	next_instruction;

push2:
	*(++sp) = *(int16_t *) (++pc);

	pc += 2;
	next_instruction;

push1:
	*(++sp) = *(int8_t *) (++pc);

	pc++;
	next_instruction;

add:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a+b;

	pc++;
	next_instruction;

sub:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a-b;

	pc++;
	next_instruction;

mul:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a*b;

	pc++;
	next_instruction;

div:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a/b;

	pc++;
	next_instruction;

mod:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a % b;

	pc++;
	next_instruction;

eq:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a == b ? 1 : 0;

	pc++;
	next_instruction;

ne:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a != b ? 1 : 0;

	pc++;
	next_instruction;

lt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a < b ? 1 : 0;

	pc++;
	next_instruction;

gt:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a > b ? 1 : 0;

	pc++;
	next_instruction;

le:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a <= b ? 1 : 0;

	pc++;
	next_instruction;

ge:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = a >= b ? 1 : 0;

	pc++;
	next_instruction;

not:
	b = *(sp--);

	*(++sp) = !b;

	pc++;
	next_instruction;

and:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) | (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

or:
	b = *(sp--);
	a = *(sp--);

	*(++sp) = ((a == 0) & (b == 0)) ? 0 : 1;

	pc++;
	next_instruction;

input:
	*(++sp) = getchar();

	pc++;
	next_instruction;

output:
	arg = *(sp--);
	putchar(arg);

	pc++;
	next_instruction;

clock:
	t = clock() - t;
	time_taken = ((double)t)/CLOCKS_PER_SEC;

	printf("%0.6lf\n", time_taken);

	pc++;
	next_instruction;

nop:
	pc++;
	next_instruction;

end:
	free(stack);
	free(byte_program);
	fclose(fp);
	exit(EXIT_SUCCESS);

	return 0;
}